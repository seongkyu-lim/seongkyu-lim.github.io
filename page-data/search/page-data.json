{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n### 1. ISP\n\n원말로 인터넷 서비스 제공자(internet service provider)을 가리킵니다. 인터넷에 접속하는 수단을 제공하는 주체를 가리키며 대게 영리를 목적으로 하는 사기업 혹은 비영리 공동체가 됩니다. ISP는 접속ISP, 호스팅ISP, 통행ISP로 나뉩니다. 접속ISP는 유선이나 무선장치를 통해 클라이언트들을 인터넷에 연결해주며, 호스팅ISP는 다른 이들에게 서버 공간을 빌려줍니다. 그리고 통행ISP는 호스팅ISP와 접속ISP를 연결하는 대량의 대역을 제공합니다. 인터넷 서비스 제공업체(ISP)들은 다양한 기술을 이용해 사람들이 다양한 환경에서 네트워크에 접속할 수 있게 도와줍니다.\n\n### 2.NAT\n\n원말로 네트워크 주소 변환(network address translation)을 가리킵니다. IP packet의 TCP/UDP 포트 숫자와 소스 및 목적지의 IP 주소 등을 재기록하면서 라우터를 통해 네트워크 트래픽을 주고 받는 기술을 지칭합니다. NAT기술은 대개 사설 네트워크에 속한 여러 개의 호스트가 하나의 공인 IP주소를 사용하여 인터넷에 접속하기위한 목적으로 사용됩니다. 즉, 내부 망에서는 사설 IP 주소를 사용하여 통신을 하고, 외부망과의 통신시에는 NAT를 거쳐 공인 IP 주소로 자동 변환 합니다. 이는 IPv4의 주소 부족 문제를 해결하기 위한 방법이 될 수 있었으며, 주로 비공인 네트워크 주소를 사용하는 망에서 위부의 공인망과의 통신을 위해 네트웍주소를 변환한 것입니다. 다만 NAT가 호스트 간의 통신에 있어서 복잡성을 증가시켜 네트워크 성능에 영향을 줄 수 있습니다. 변환방식으로는 Full-cone NAT, (Address)-restricted-cone NAT, Port-restricted coneNAT, Symmetric NAT이 있습니다.\n\n### 3. DHCP\n\n원말로 동적 호스트 구성 프로토콜(dynamic host configuration protocol)을 가리킵니다. 호스트 IP 구성 관리를 단순화하는 IP 표준입니다. 즉, 대규모의 기업과 같이 많은 디바이스를 관리해야할 경우, IP를 지정해서 사용할 때 IP관리가 힘들수 있습니다. 따라서 DHCP를 사용하여 서버에 설정되어있는 IP주소를 자동으로 할당 받는 것으로 쉽게 IP를 관리 할 수 있습니다. 즉, DHCP 서버를 사용하여 IP 주소 및 관련된 기타 구성 세부 정보를 네트워크의 DHCP 사용 클라이언트에게 동적으로 할당하는 방법을 제공합니다. 동작 원리는 크게 네 단계로(discover, offer, request, ack) 단말과 서버 간에 통신이 이루어집니다. 하지만 DHCP 서버에서 모든 IP가 할당되므로 서버가 다운되면 IP할당이 안되어 인터넷 사용이 불가능하게 됩니다.\n\n### 4. Congestion\n\ncongestion(혼잡) 은 네트워크 분야에서는 정보 통신 네트워크로 들어가는 정보 소통량(패킷 수)으로 인한 네트워크 혼잡을 뜻합니다. 정보 소통량이 과다하면 네트워크가 congestion이 될 것입니다. 이러한 congestion을 컨트롤하는 것을 혼잡 제어(congestion control)이라고 하며 정보 소통량을 조절하여 네트워크가 혼잡해지는 것을 방지하는 것을 말합니다. 만약 정보 소통량이 과다하면 패킷을 조금만 전송하게 하여 혼잡 붕괴 현상이 일어나는 것을 막을 수 있습니다. Transport layer의 TCP가 대표적으로 혼잡제어 기능을 처리합니다.\n\n### 5. DNS\n\n원말로 도메인 네임 시스템(domain name system) 혹은 도메인 네임 서버(domain name server)을 가리킵니다. 호스트의 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행할 수 있도록 하기 위해 개발되었습니다. 특정 네트워크에 연결된 기기의 주소를 찾기 위해 사람이 이해하기 쉬운 도메인 이름을 숫자로 IP주소로 변환해 줍니다. DNS는 앞서 설명한 시스템 자체를 가리키키도하고 이러한 역할을 하는 서버컴퓨터를 (domain name server)를 가리키기도합니다. 예를 들어 사이트에 접속을 하기 위해서는 해당 사이트에 대한 정보를 가지고 있는 IP주소를 알아야하는데 Domain name server가 도메인에 연결된 IP주소를 찾아 줍니다.\n\n### 6. HTTP / HTTPS\n\n원말로 hypertext transfer protocol / hypertext transfer protocol over secure socket layer 을 가리킵니다. http는 w3 상에서 정보를 주고받을 수 있는 프로토콜이며 주로 html문서를 주고 받는데 사용됩니다. 클라이언트인 웹 브라우저가 http를 통하여 웹 서버로부터 웹 페이지나 그림 정보를 요청하면, 웹 서버는 이 요청에 응답하여 필요한 정보를 해당 사용자에게 전달하게 됩니다. 주로 TCP를 사용하고 HTTP/3 부터는 UDP를 사용하며 80번 포트를 사용합니다.http는 단순 텍스트를 사용하기에 보안에 취약합니다. https는 이러한 http의 보안이 강화된 버전입니다. Https는 통신의 인증과 암호화를 위하여 개발되었으며 전자 로그인에서 널리 쓰입니다. 소켓 통신에서 일반 텍스트를 이용하는 대신에 SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화합니다. 기본 TCP/IP 포트는 443입니다.\n\n### 7. NIC\n\n원말로 네트워크 인터페이스 컨트롤러(network interface controller)를 가리킵니다. 컴퓨터를 네트워크에 연결하여 통신하기 위해 사용하는 하드웨어 장치입니다. 케이블에 데이터를 실어서 허브,스위치,라우터 등으로 전달해주거나 자신에게 온 데이터를 cpu에게 전달해주고 케이블과 컴퓨터사이의 데이터 흐름을 제어하는 역할을 합니다. 즉, 네트워크 상의 데이터를 주고 받아주는 장치입니다.\n\n### 8. MAC\n\nIP주소를 logical 주소라고 한다면 Mac 주소는 physical 주소라 합니다. Media access control 의 약자로 맥 주소라고도 합니다. 맥주소는 네트워크 세그먼트의 데이터 링크 계층에서 통신을 위한 네트워크 인터페이스에 할당된 고유 식별자입니다. 앞서 설명한 NIC와 같은 네트워크 장비들이 하나씩 가지고 있는 유일하고 고정된 48bit 주소입니다.\n\n### 9. LAN / MAN / WAN\n\nLAN, MAN, WAN 은 각각 네트워크를 크기에 띠라 분류하는 단어입니다. 각각 Local area network(근거리 통신망), metropolitan area network(도시 지역 통신망), wide area network(광역통신망)의 약어입니다. 이름에서 알 수 있듯이 LAN < MAN < WAN 순서로 네트워크의 범위가 커집니다. 예를 들자면 LAN단위에서는 집, 사무실, pc방, MAN단위에서는 한개 도시정도의 크기, WAN단위에서는 그보다 큰범위(MAN이 모여서 형성 혹은 근거리 네트워크를 벗어나 라우터간의 통신이되는 모든 영역)가 됩니다. 네트워크를 크기에 따라 분류한 이유는 트래픽을 최소화하기 위함입니다.\n\n### 10. SSL / TLS\n\n원말로 TLS는 전송 계층 보안(transport layer security), SSL은 보안 소켓 레이어(secure sockets layer)을 가리킵니다. TLS는 컴퓨터 네트워크에 통신 보안을 제공하기 위해 설계된 암호규약이며 SSL이 표준화가 되면서 TSL로 이름이 바뀌었습니다. TSL은 인터넷과 같이 TCP/IP 네트워크를 사용하는 통신에 적용되며, 통신 과정중 전송계층 종단간 보안과 데이터 무결성을 확보해줍니다. 웹 브라우징, 전자 메일, 인스턴트 메신저, VoIP와 같은 응용 분야에 적용되고 있습니다. 크게 3단계 기본 절차가 있으며 1. 지원 가능한 알고리즘 서로 교환 2. 키 교환, 인증 3. 대칭키 암호로 암화하하고 메시지 인증 단계를 거칩니다.\n\n### 11. Stream-oriented /Chunk-oriented\n\n우선 단어의 뜻을 생각해보면 stream은 시냇물과 같은 데이터 줄기(열,집합), chunk는 데이터 덩어리(조각)을 의미합니다. stream-oriented는 말그대로 스트림 지향이며(cs에서 stream은 시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소를 가리키는 수많은 방식에서 쓰임.) 스트림 지향 프로토콜(TCP)가 있습니다. TCP는 transport layer에 해당되는 프로토콜로서 IP와 함꼐 TCP/IP를 구성합니다. TCP는 stream-oriented 로써 상위 계층으로부터 데이터 스트림을 수신하고 세그먼트라고하는 적절한 패킷 단위로 스트림을 나눕니다. 세그먼트들은 네트워크를 통해 전송되어 목적지 TCP에 의해 재조립됩니다. 즉, 큰 줄기로 데이터가 들어와 쪼개지더라도 순서를 유지한채 다시 큰 줄기로 합쳐집니다. 반면 chunk-oriented 는 패킷으로 쪼개져서 각각의 패킷(chunk)이 독립적인 관계를 가져 각각의 패킷은 다른경로로 전송되어 최초의 순서와 상관없이 각각의 패킷(chunk)이 독립적으로 목적지에서 재조립됩니다. 앞서 설명한 TCP와 비교하여 UDP를 예로 들 수 있겠습니다.\n\n### 12. E2E communication\n\nE2E 는 End to end를 의미하며 단어 그대로 해석해보면 끝에서 끝까지 통신이라고 해석할 수 있습니다. 즉 네트워크 상에서 우리가 원하는 host에 바로 연결하면 좋지만 그 과정에서 많은 router들을 거쳐야합니다. 우리가 전송, 혹은 전달 받고자 하는 데이터가 정확하게 끝(end)에서 끝(end)으로 주고받는 것을 E2E communication이라 할 수 있습니다. 이렇게 e2e communication을 하기위한 원칙을 엔드 투 엔드 원칙(e2e principle)이라 합니다. e2e principle은 컴퓨터 네트워킹의 디자인 프레임 워크이며 이 원칙에 따라 설계된 네트워크에서 응용 프로그램 별 기능은 네트워크를 설정하기 위해 존재하는 게이트웨이 및 라우터와 같은 중간 노드가 아닌 네트워크의 통신 끝 노드에 있습니다.\n\n### 13. AS (Autonomous System)\n\n자율 시스템(AS)은 인터넷에서 동일한 관리자에 의해 여러 내부 라우팅 프로토콜을 동일한 정책을 통해 관리되는 라우터들과 서브네트워크 들의 집합입니다. 즉, 하나의 관리 통제 하에 있는 영역을 뜻합니다. 네트워크는 라우팅 정책의 독립성, 보안 유지, 고장 및 오류의 국지화, 트래픽양 최소화등을 위해 AS에 의해 분리됩니다.\n","excerpt":"1. ISP 원말로 인터넷 서비스 제공자(internet service provider)을 가리킵니다. 인터넷에 접속하는 수단을 제공하는 주체를 가리키며 대게 영리를 목적으로 하는 사기업 혹은 비영리 공동체가 됩니다. ISP는 접속ISP, 호스팅IS…","fields":{"slug":"/network-acronyms/"},"frontmatter":{"date":"Sep 16, 2020","title":"computer networks jargons and acronyms","tags":["network"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n### .replace()\n","excerpt":".replace()","fields":{"slug":"/python-string/"},"frontmatter":{"date":"Sep 16, 2020","title":"String method in Python","tags":["python","string","method"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\npull-request를 하기 위해서는 당연하게도 우선 upsteam repository에서 fork한 repository를 upstream 과 동기화하는 과정이 선행되어야합니다.\n\n제가 만약 월요일날 처음 fork를 땄고 금요일 날 까지 자신이 맡은 부분의 코드를 완성하여 pull-request를 하려하는 상황일 때,\n\nupstream repository에는 월요일부터 금요일 사이에 자신말고도 다른 누군가에 의해 많은 부분이 수정,추가,제거 되었을 수 있습니다.\n\n따라서 pr을 날리기 전에는 반드시 upstream과 동기화를 거친 후 pr을 할 필요가 있습니다.\n\n동기화를하는 방법은 다음과 같습니다.\n<br>\n<br>\n\n```\nGit fetch upstream\n\nGit checkout master or git Checkout -b master —track origin/master\n\nGit merge upstream/master\n\nGit push\n```\n","excerpt":"pull-request를 하기 위해서는 당연하게도 우선 upsteam repository에서 fork한 repository를 upstream 과 동기화하는 과정이 선행되어야합니다. 제가 만약 월요일날 처음 fork를 땄고 금요일 날 까지 자신이 맡은…","fields":{"slug":"/git-fork-sync/"},"frontmatter":{"date":"Sep 10, 2020","title":"upsteam과 fork한 저장소 동기화","tags":["git"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n최초에 github을 이용하여 나만의 코드들을 저장할 저장소, repository를 github 사이트에서 생성하면 이 repository는 원격저장소(remote repository)가 됩니다.\n\n실질적으로 코드 생성은 개인의 컴퓨터에서 하게 되는데 개인의 컴퓨터에 존재하는 repository는 로컬저장소(local repository)가 됩니다.\n\n최초에 repository를 생성할시 사이트에 존재하는 remote repository와 개인의 컴퓨터에 존재하는 local repository를 연동해줄 필요가 있습니다.\n\ncommit 이나 pull, push 는 vscode나 atom, intelliJ와 같은 코드 편집기, 개발 환경 툴에서 코드를 생성하고 곧바로 그 환경에서 하는 것이 편하지만\n\n처음 repository를 연동하는 것은 터미널(mac 기준)에서 하는 것이 편하고 깔끔하다고 생각이되어 git bash로 하는 편입니다.\n\ngit bash를 이용하여 두 저장소를 연동하는 방법은 다음과 같습니다.\n\n<br>\n<br>\n\n1. 로컬저장소로 만들 파일로 위치 이동.\n\n2. 로컬 저장소로 설정 (한번 설정하면 끝)\n\n```\ngit init\n```\n\n3. 파일들을 staging area || index로 이동\n\n```\ngit add . || file_name\n```\n\n. 은 전부를 추가하고 file_name을 써주면 해당 file만 추가됩니다.\n\n4. staging area 의 파일들을 로컬 저장소에 저장\n\n```\ngit commit -m “”\n```\n\n\"\"안에 간략한 commit message를 입력\n\n5. 로컬저장소와 원격저장소 연결 (처음에만 연결해주면 됨)\n\n```\ngit remote add origin [원격저장소주소]\n```\n\n6. 원격저장소에 저장\n\n```\ngit push -u origin master\n```\n\nLocal repository check\n\n```\ngit status\n```\n\n6번까지의 과정을 마쳐 저장소 연동이 끝나면 그 뒤로는 3(add),4(commit),6(push)의 과정만을 반복하여 로컬 저장소에서 수정,제거,추가한 코드들을 원격저장소에 저장하면 됩니다.\n","excerpt":"최초에 github을 이용하여 나만의 코드들을 저장할 저장소, repository를 github 사이트에서 생성하면 이 repository는 원격저장소(remote repository)가 됩니다. 실질적으로 코드 생성은 개인의 컴퓨터에서 하게 되는데…","fields":{"slug":"/git-repository/"},"frontmatter":{"date":"Sep 10, 2020","title":"repository 생성 후 초기 세팅 git bash로 해결하기","tags":["git"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n#### Point\n\n<b>첫번 째</b>로 input() 함수는 문자열로 입력받기 때문에 입력받을 때 정수로 자료형을 바꾸어주자.\n\n<b>두번 째</b>로 많은 줄의 입력 데이터가 있을 시 빠르게 입력 받도록 하기위해 sys.stdin.readline을 사용하자.\n\n입출력 속도 비교 : sys.stdin.readline > raw_input() > input()\n<br>\n<br>\n\n### 첫번 째\n\n#### 1. 한개 입력받는 방법\n\n```python\n\na = int(input())\n\nprint(a)\n\n#int()를 사용하여 input()으로 입력받은 입력값의 자료형을 string 에서 int로 바꾸어 줍니다.\n```\n\n#### 2. 여러개를 한줄에 입력받는 방법\n\n```python\n\na, b = input().split()\n\n#.split() 는 소괄호안의 문자를 기준으로 입력값을 나누어 받는다. 소괄호안에 아무 것도 없을 경우 공백을 기준으로 받는다.\n# input().split()으로 받을 경우에는 int()를 사용하지 못한다. -> 해결법  : map method를 사용\n\na, b  = map(int, input().split())\n\n# 입력받은 값들을 int로 형변환한다.\n\n```\n\n### 3. 2차원 배열 입력받는 방법.\n\n```python\n\nboard = [[int(x) for x in input().split()] for y in range(n)]\n\n#n 은 행의 개수를 의미한다. (세로줄)\n\n```\n\n<br>\n\n### 두번 째\n\n```python\n\nfrom sys import\\*\n\ninput = stdin.readline\n\n# 위의 코드형식으로 선언하고 input() 사용하던대로 사용하면 빠르게 입력 받을 수 있다.\n\n```\n","excerpt":"Point 첫번 째로 input() 함수는 문자열로 입력받기 때문에 입력받을 때 정수로 자료형을 바꾸어주자. 두번 째로 많은 줄의 입력 데이터가 있을 시 빠르게 입력 받도록 하기위해 sys.stdin.readline을 사용하자. 입출력 속도 비교 :…","fields":{"slug":"/python-algo-input/"},"frontmatter":{"date":"Sep 10, 2020","title":"알고리즘 문제를 풀 때, 파이썬에서 정수 입력값 받는 방법","tags":["algorithms","python"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n게시물에 태그를 지정할 수 있습니다.\n\n해당 게시물의 Markdown YAML Front matter은 아래와 같습니다.\n\n```\n---\ntitle: Tag, 태그 게시물 예제\ndate: 2019-07-30\ntags:\n  - tag\n  - 태그\n---\n```\n\n가이드의 Markdown YAML Front matter를 참고하세요.\n\n자세한 가이드는 [Documents](<https://github.com/junhobaik/junhobaik.github.io/wiki/Document-(Borderless)>)를 확인해주세요.\n","excerpt":"게시물에 태그를 지정할 수 있습니다. 해당 게시물의 Markdown YAML Front matter은 아래와 같습니다. 가이드의 Markdown YAML Front matter를 참고하세요. 자세한 가이드는 Documents를 확인해주세요.","fields":{"slug":"/tag-post-example/"},"frontmatter":{"date":"Mar 24, 1991","title":"Tag, 태그 게시물 예제","tags":["tag","태그"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n![](screenshot.png)\n\n이미지 파일이 첨부된 게시물의 예제입니다.\n\n폴더를 만들고 폴더의 제목이 해당 게시물의 주소가 됩니다.\n\n게시물 파일명은 index.md 로 합니다.\n\n이미지 파일은 폴더 내에 위치시킵니다.\n\n자세한 가이드는 [Documents](<https://github.com/junhobaik/junhobaik.github.io/wiki/Document-(Borderless)>)를 확인해주세요.\n","excerpt":"이미지 파일이 첨부된 게시물의 예제입니다. 폴더를 만들고 폴더의 제목이 해당 게시물의 주소가 됩니다. 게시물 파일명은 index.md 로 합니다. 이미지 파일은 폴더 내에 위치시킵니다. 자세한 가이드는 Documents를 확인해주세요.","fields":{"slug":"/image-post-example.md/"},"frontmatter":{"date":"Mar 24, 1991","title":"Image, 이미지 게시물 예제","tags":["undefined"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n블로그를 본인에 맞춰 커스터마이징하려면 우선 config.js의 수정이 필요합니다.\n\n[Documents](<https://github.com/junhobaik/junhobaik.github.io/wiki/Document-(Borderless)>)를 확인해주세요.\n","excerpt":"블로그를 본인에 맞춰 커스터마이징하려면 우선 config.js의 수정이 필요합니다. Documents를 확인해주세요.","fields":{"slug":"/first-post/"},"frontmatter":{"date":"Mar 23, 1991","title":"Borderless Documents","tags":["undefined"],"update":"Mar 08, 2020"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}